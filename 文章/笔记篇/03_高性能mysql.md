## 索引

### 聚簇索引

其实就是俗称的主键索引，它是一种数据的存储方式。innoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。

也就是说聚簇索引会和其他的索引放在同一个数据结构上，可以理解为冗余，因为他要定位数据行的位置。

优点:

- 通过少数的数据页就能获取到数据行，
- 访问更快,有顺序性的连续的。
- 覆盖索引扫描的查询可以直接使用叶节点中的主键值

缺点:

- 如果数据是放在内存中，访问的顺序就没那么重要了，聚簇索引就没啥优势
- 插入速度严重依赖插入顺序，如果数据没有顺序的话需要optimize table命令重新组织下表
- 更新聚簇索引的代价很高。
- 聚簇索引会导致全表扫描变慢,尤其是行比较稀疏
- 聚簇索引会增加其他二级索引(非聚簇索引)的大小，因为在二级索引的叶子节点包含了引用的数据行。



### 覆盖索引

从建立的索引当中提取结果集，并返回给客户端。

但是针对`select * ` 这种操作是无法使用覆盖索引的。

它带来的好处是:

1. 不需要回表、直接拿索引数据返回。
   1. 减少数据的访问、降低缓存的负载。
2. 索引是按照列值顺序存储的，所以对I/O**密集型的范围查询**会比随机读取每一行数据的IO数据少的多。
3. 降低磁盘IO
4. 由于InnoDB的聚簇索引、覆盖索引对innodb特别有用，InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

### 使用索引扫描来做排序

mysql的排序方式有两种:

- 索引排序
- 字段排序

索引排序本身是很快的，但如果不能覆盖全部的查询列，那么会意味着需要回表找到对应的列再重新排序。这基本上都是随机IO,因此按照索引顺序读取数据的速度通常比顺序的全表扫描慢，尤其是在IO密集型的工作负载时。

**如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一张表时，才能使用索引做排序。**

order by子句和查询的限制是一样的： 需要满足最左前缀的要求。否则mysql都需要执行排序操作，而无法利用索引排序；







