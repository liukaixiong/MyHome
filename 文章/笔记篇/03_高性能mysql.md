## 索引

### 聚簇索引

其实就是俗称的主键索引，它是一种数据的存储方式。innoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。

也就是说聚簇索引会和其他的索引放在同一个数据结构上，可以理解为冗余，因为他要定位数据行的位置。

优点:

- 通过少数的数据页就能获取到数据行，
- 访问更快,有顺序性的连续的。
- 覆盖索引扫描的查询可以直接使用叶节点中的主键值

缺点:

- 如果数据是放在内存中，访问的顺序就没那么重要了，聚簇索引就没啥优势
- 插入速度严重依赖插入顺序，如果数据没有顺序的话需要optimize table命令重新组织下表
- 更新聚簇索引的代价很高。
- 聚簇索引会导致全表扫描变慢,尤其是行比较稀疏
- 聚簇索引会增加其他二级索引(非聚簇索引)的大小，因为在二级索引的叶子节点包含了引用的数据行。



### 覆盖索引

从建立的索引当中提取结果集，并返回给客户端。

但是针对`select * ` 这种操作是无法使用覆盖索引的。

它带来的好处是:

1. 不需要回表、直接拿索引数据返回。
   1. 减少数据的访问、降低缓存的负载。
2. 索引是按照列值顺序存储的，所以对I/O**密集型的范围查询**会比随机读取每一行数据的IO数据少的多。
3. 降低磁盘IO
4. 由于InnoDB的聚簇索引、覆盖索引对innodb特别有用，InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

### 使用索引扫描来做排序

mysql的排序方式有两种:

- 索引排序
- 字段排序

索引排序本身是很快的，但如果不能覆盖全部的查询列，那么会意味着需要回表找到对应的列再重新排序。这基本上都是随机IO,因此按照索引顺序读取数据的速度通常比顺序的全表扫描慢，尤其是在IO密集型的工作负载时。

**如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一张表时，才能使用索引做排序。**

order by子句和查询的限制是一样的： 需要满足最左前缀的要求。否则mysql都需要执行排序操作，而无法利用索引排序；



### 延迟关联

通过使用覆盖索引返回需要的主键，然后再根据这些主键关联原表获得需要的行。



## 查询性能优化

### 慢查询优化基础，优化数据访问

#### 减少非必要的返回列

大部分SQL是*号返回所有列，会让优化器无法完成索引覆盖扫描这些类优化，还会为服务器带来额外的IO\内存和CPU的消耗。

如果服务器和数据库不在同一台上面，网络开销会很明显。

### Mysql是否在扫描额外的记录

在确定查询只返回需要的数据后,接下来应该看看查询为了返回结果是否扫描了过多的数据。对于Mysql的衡量指标：

- 响应时间
- 扫描的行数
- 返回的行数

一般mysql能够使用如下三种方式应用WHERE条件，从好到坏依次为：

- 在索引中使用WHERE条件来过滤不匹配的就.这是在存储引擎层完成的。
- 使用索引覆盖扫描(**在Extra列中出现了Using index**)来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在Mysql服务器层完成的，但无须回表查询记录。
- 从数据表中返回数据,然后过滤不满足的条件记录(**在Extra列中出现Using Where**)，这是在mysql服务器层完成，mysql需要先从数据表中读出记录然后过滤。

如果发现查询需要扫描大量数据，但是只返回少量的行，那么通常可以尝试下面的技巧去优化它：

- 使用索引覆盖扫描，把所有需要用的列都放在索引中，这样存储引擎无需回表获取对应行就行了.
- 改变库表结构，例如使用单独汇总表。
- 重写这个复杂的查询。

### 重构查询的方式

### 一个复杂的查询还是多个简单的查询。

考虑业务是否能够支持多个查询然后聚合，当然这适用于没有表关联的。

### 切分查询

分而治之的思想，如果需要删除一大批数据，先查再删，势必会引起锁的发生。可以尝试查一条删一条，慢慢来。

### 分解关联查询

将一条表关联的查询拆解成多条查询。

他所带来的优势:

1. 缓存的效率更高，
2. 单个查询减少锁之间的竞争.
3. 分库分表更有优势,减少表之间的耦合。
4. 减少冗余查询的记录.



## 优化特定类型的查询

### 优化Count查询

count他可以统计某个列值的数量也可以统计行数，在统计列值时要求列值是非空的（不统计null），

如果在count（）的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。

count(*)表示其实会忽略所有的列而直接统计所有的行数。

# Extra

- Impossible Where noticed after reading const tables；
  - 表示提前终止查询，如触发limit
- Using filesort
  - 表示如果order by字句中的所有列都来自关联的第一个表。
- Using temporary Using flesort
  - Mysql会先将关联的结果存放到一个临时表中，然后在所有的关联都结束后，再进行文件排序。如果有limit的话，Limit也会在排序之后应用，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然会非常大。
-  Using index for group-by
  - 表示这里将使用松散索引扫描。

**如果Mysql花费大量的时间在"statistics"状态，加上`STRAIGHT_JOIN`这个提示则会大大减少优化的搜索空间。(一般是表关联过多的情况) **

**force index 在优化器选择了错误的索引之后，可以指定强制的索引名称。**

**改变优化器的执行，固然会获得一些提升，但是在升级的时候，可以会让新版优化器的优化功能失效。**


