# 消息队列

## 作用

### 1. 解耦

- 拆解服务中的调用

### 2. 异步

服务器接口异步化，拆分。同步调用拆为异步。具有重试、回调等种种功能。

### 3. 削峰

1. 秒杀场景。

## 引入的问题

### 1. 系统可用性降低

- MQ出了问题，系统崩溃。
  - 系统A无法通知系统BCD、系统无法运转。



### 2. 复杂性提高

- 保证可用性。
- 消息的重复发送和消费。[幂等]
- 消息丢失了。
- 消息的顺序性。
- 一致性问题。消费失败了，重试机制。



### 3.

## 各MQ对比

### 单机吞吐量

rocketMQ、kafka 十万级。

###  JAVA

RocketMQ、ActiveMQ、kafka

### 支持分布式

RocketMQ、Kafka

**总结**

中小型可以尝试使用rabbitmq。

稍大型公司可以尝试使用rocketMQ，最好是能有改造能力的。

实时计算、日志采集用kafka。





## 消息队列的高可用

### rocketMQ

#### 主备模式

4.5.0版本之后引入Dleger进行容灾切换



#### 多Master多Slave模式 - 异步复制

每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟。

**优点**

即使磁盘损坏，消息丢失的非常少，且消息的实时性不会受到影响，同时Master宕机后，消费者仍然可以从Slave消费，而且过程对应用透明，不需要人工干预，性能同多Master模式几乎一样。

**缺点**

Master宕机后，磁盘损坏情况下会丢失少量消息。因为它是异步的。



#### 多Master多Slave模式 - 同步双写

只有主备都写成功，才向应用返回成功。

**优点**

数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性和数据可用性都非常高。

**缺点**

性能比异步复制略低（官方说是10%左右），发送单个消息的RT会略高。

## 消息队列的最佳实践

### 提高消费者的并行度

也就是增多消费者。消费者越多，处理消息就越快。

> 但是这里要注意的是：消费者数量不要超过topic下Read Queue的数量，**不然会出现多的消费者接受不到消息。**

### 提高处理线程数

提高单个消费者的并行处理线程数。

设置是方式是修改

```java
consumer.setConsumeThreadMin()
consumer.setConsumeThreadMax()
```



### **批量消息消费**

某些业务场景下，多条消息同时处理的时间会大大小于逐个处理都是时间总和，比如批量修改10条数据比一次次修改10条数据会快.

实现方式是:

```java
consumer.setConsumeMessageBatchMaxSize
```



## 数据丢失的方案

消息丢失的三个关键节点:

1. 生产者发送给MQ。
2. MQ复制到slave节点的时候。
3. 消费者消费的时候丢了。

**问题1 :** 

重要业务场景，发送失败了，利用重试机制，比如3次，还是失败了，业务直接返回失败。

缺点: 同步执行，影响业务！

非重要业务，如果发送MQ失败了，将消息进行保存，通过其他服务定时轮训这个消息，进行重试。



**问题2 :** 

RocketMQ分为同步双写和异步双写：

1. 同步双写，发送到主Master之后，主复制到Slave成功之后才会直接返回成功。但是性能会有损耗。
2. 异步双写: 消息发送到主Master成功之后，直接返回。不排除Master挂了消息丢失，但是性能好。



**问题3 :** 

**手动提交**

消费者如果消费失败了，需要返回一个消费失败的标记。然后MQ执行重试机制。

极端情况: 消费者消费时间过长，直接超时了，MQ认为失败了，但是实际上执行成功了，这个时候需要做幂等。防止重复消费，可以本地构建消息表。





