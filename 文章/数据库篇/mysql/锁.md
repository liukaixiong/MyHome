# Mysql的锁机制

[参考](https://blog.csdn.net/varyall/article/details/80219459)

## 基本锁

1. 共享锁
2. 排它锁

mysql允许拿到共享锁的事务读一行，允许拿到排他锁的事务更新或删除一行。
加了共享锁的记录，允许其他事务再加共享锁，不允许其他事务再加排他锁；
加了排他锁的记录，不允许其他事务再加共享锁或者排他锁。

mysql对外提供加这两种锁的语法如下：
**加共享锁：**

```sql
SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
```

**加排他锁：**

```SQL
SELECT * FROM table_name WHERE ... FOR UPDATE
```

InnoDB:

行锁:基于索引实现的。如果不通过索引访问数据，则会使用表锁。

介绍了InnoDB间隙锁（Next-key)机制，以及InnoDB使用间隙锁的原因。 

在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：

- 尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；
- 选择合理的事务大小，小事务发生锁冲突的几率也更小；
- 给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；
- 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；
- 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；
- 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。