# 下面是关于JVM相关的面试集锦 

## java虚拟机的运行时数据区有几块？线程私有和线程共享区域有哪些？
1. 程序计数器 ; 线程私有，当前线程执行的字节码指示器
2. 栈 ： 线程私有，存放基本数据类型以及对象引用和返回地址类型。
3. 本地方法栈：为虚拟机使用到的Native方法服务。
4. 堆：线程共享，存放对象的实例，也是GC回收器的主要区域。
5. 方法区：线程共享，存放已被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。
6. 运行常量区：方法去的一部分，存放编译期生成的各种字面变量和符号引用。


## Java内存模型

> ①Java内存模型分为主内存和工作内存两个部分，其中主内存存放变量，工作内存由每个线程创建和管理，保存被该线程使用到的变量的主内存的副本拷贝。变量从主内存复制到工作内存，顺序执行read和load操作，变量从工作内存同步到主内存的时候，顺序执行store和write操作.  
> 对于volatile变量在各个线程的一致性：在各个线程的工作内存中，volatile存在不一致的情况，但在每次使用前都会刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题。

> ②原子性、可见性和有序性

> ③先行发生原则

## 什么是内存屏障(memory Barrier) ? 
    其实就是一个CPU的指令,这个指令的意思是:  
    1. 保证特定的操作顺序执行(静止重排序)
    2. 影响某些数据(或者是某条指令的执行结果)的可见性(volatile).

## volatile的作用
    1. 使用volatile修饰的变量在写入时,其他线程能够可见.
    2. 因为写入的变量会重新刷入到主内存中,其他线程的工作内存中该变量的值会被置为无效...
    
    它相当于一个轻量级的synchronized,因为volatile不会引起上下文切换


## volatile的使用场景:

> volatile提供内存可见性和禁止内存重排序


  约束条件:
1. 当前变量的写操作不依赖当前值,例如a++,这种是无法通过volatile保证原子性的.
2. 该变量没有包含在具有其他变量的不变式中。(volatile变量不能用于约束条件中)  
  常用场景:  

3. 状态的标记位
4. 一次性安全发布
5. 独立观察
6. 开销较低的读写锁策略.
7. 一个线程写,多个线程读.

## 什么是happens-before原则?
> 表示当前指令的执行依赖上一个指令的执行的结果:  

```
    int a = 100;
    // 当前指令依赖上一个指令的结果
    int b = a + 200;
```

## volatile 是如何让其他线程感知到变量的修改的?
> 假设其他处理器中的缓存的值是旧的,在运行计算的时就会出问题,所以处理器通过在嗅探在总线上传播的数据来检查缓存中的值是不是已经过期了,当处理器发现自己缓存中的值不是最新的,就会将值设置成无效状态,当处理器要对这个数据进行操作的时候,又会强制把数据读取到缓存中。


## volatile 的优化
> 一个对象的引用占用4个字节,它追加了15个变量共占60个字节,在加上value的变量一个64个字节.

- 为什么追加64字节可以提高并发编程的效率?
    - 非64字节的队列,处理器试图改变头节点时会将整个缓存行进行锁定.影响出队入队的效率.
    - 而64位的自己,即便你改动头节点,尾节点也不会被锁定...

参考 : http://www.cnblogs.com/mthoutai/p/6766874.html


## 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。
答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；   
而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；  
方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；  
程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在常量池中，常量池是方法区的一部分，。  
栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。