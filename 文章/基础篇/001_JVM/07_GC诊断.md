# GC相关案例记录

http://mp.weixin.qq.com/s/t1Cx1n6irN1RWG8HQyHU2w

- **为什么JVM中的堆要划分成多个不同的物理区域?**

  因为它的垃圾回收机制都是采用分代回收的算法，对于对象的生命周期的不同，可以采用不同的回收方式，以便提高回收效率

- **每个阶段的区域的晋升机制**

  - 新生代

    新生代划分为三个区域:**一个eden区域**，**两个survivor区域**

    大部分对象都在eden区中生成，当eden区域满了的时候,还存活的对象将被复制到survivor 0区域

    当这个survivor 0的区域满了之后,还**存活且不满足的晋升条件**的对象将被复制到另一个Survivor 1区域

    对象每经历一次minor GC，**年龄增加1** ,达到晋升年龄阀值后,被放到老年代.这个过程也称之为晋升。这个晋升年龄的设定也决定了对象在新生代的停留时间。

    通过**MaxTenuringThreshold**设定，默认15.

  - 老年代

    老年代的垃圾回收一般是通过"**标记-清除**"或者"**标记-整理**"算法。

    只有在触发full GC的时候会在老年代和新生代共同回收。

    一般是在System.gc() 或者老年代空间不足的时候,会触发。

  - 持久代

  主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。

- 常见的垃圾回收器

  - 串行

    - 单线程回收
    - 简单、容易实现、高效

  - 并行

    - 串行的多线程版本
    - 充分利用CPU资源，减少垃圾回收的时间

    ​

## GC大小分配策略

堆的大小划分对GC的性能影响非常大。

一般在程序稳定的时候，多次获取GC数据通过平均值的方式计算活跃数据的大小

一般的划分规则:

- 总大小
  - 3-4呗的活跃数据的大小
- 新生代
  - 1-1.5倍活跃数据的大小
- 老年代
  - 2-3倍数据活跃大小
- 永久代
  - 1.2-1.5倍full Gc后的永久区大小

例如，根据GC日志获得老年代的活跃数据大小为300MB，那么各分区大小可以设为：

> 总堆：1200MB = 300MB × 4
> 新生代：450MB = 300MB × 1.5
> 老年代： 750MB = 1200MB - 450MB*

这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。



## 优化步骤

1. ### **确定目标**

   明确应用程序的系统需求是性能优化的基础，系统的需求是指应用程序运行时某方面的要求，譬如：

   - 高可用，可用性达到几个9。
   - 低延迟，请求必须多少毫秒内完成响应。
   - 高吞吐，每秒完成多少次事务。

   明确系统需求之所以重要，是因为上述性能指标间可能冲突。比如通常情况下，缩小延迟的代价是降低吞吐量或者消耗更多的内存或者两者同时发生。

   由于笔者所在团队主要关注高可用和低延迟两项指标，所以接下来分析，如何量化GC时间和频率对于响应时间和可用性的影响。通过这个量化指标，可以计算出当前GC情况对服务的影响，也能评估出GC优化后对响应时间的收益，这两点对于低延迟服务很重要。

   举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：

   ![img](https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV0a8RiaD6p2fV75LI7IdZVM5buIO9jxJNPSN0k8WzwVm2yhnuwR6ic2TTHVZU9zMcpm8XlPBztHpYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

   那么有(50ms+25ms)/T比例的请求会受GC影响，其中GC前的50ms内到达的请求都会增加25ms，GC期间的25ms内到达的请求，会增加0-25ms不等，如果时间T内发生N次GC，受GC影响请求占比=(接口响应时间+GC时间)×N/T 。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。

   ### **优化**

   通过收集GC信息，结合系统需求，确定优化方案，例如选用合适的GC回收器、重新设置内存比例、调整JVM参数等。

   进行调整后，将不同的优化方案分别应用到多台机器上，然后比较这些机器上GC的性能差异，有针对性的做出选择，再通过不断的试验和观察，找到最合适的参数。

   ### **验收优化结果**

   将修改应用到所有服务器，判断优化结果是否符合预期，总结相关经验。

   接下来，我们通过三个案例来实践以上的优化流程和基本原则（本文中三个案例使用的垃圾回收器均为ParNew+CMS，CMS失败时Serial Old替补)。