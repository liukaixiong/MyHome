

![时间轮 (1)](02_时间轮.assets/时间轮 (1).png)

优点: 

- 只要时间跨度越短，精确度越高；
- 管理特别多的超时任务会非常方便;
- 心跳检测间隔时间等等;
- 支持动态插入

缺点:

- 如果时间跨度很大，数量也很大，单层的时间轮的round也很大；
- 数组长度越短,链表越长，这里需要权衡时间和空间
- 单个任务执行的时间很长的话，会对下一个任务受影响。产生堆积

> 其实只要数组够大，链表长度会随之减少，同时轮回数也会减少。

当然这都是单层时间轮，同时也可以引入多层时间轮的概念，在**kakfa**中对延迟消息有应用。

还有如果单个任务执行效率很差的话，会产生堆积，不过引入线程池来负责执行任务的话可以降低单个任务的影响程度.

至于持久化的问题，其实可以引入Mysql或者其他存储引擎，稍微改造一下也是可以支持重启恢复的。



```java
// io.netty.util.HashedWheelTimer.Worker#run
public void run() {
    // 初始化startTime.只有所有任务的的deadline都是相对于这个时间点，代表当前已经开始运行
    HashedWheelTimer.this.startTime = System.nanoTime();
    if (HashedWheelTimer.this.startTime == 0L) {
        HashedWheelTimer.this.startTime = 1L;
    }
	
    // 这里是为了start启动方法在等待的时候唤醒
    HashedWheelTimer.this.startTimeInitialized.countDown();

    int idx; 
    HashedWheelTimer.HashedWheelBucket bucket;
    // 只要时间轮的状态是启动的，就一直不停的移动tick时针，循环拉取数组下标中的任务进行计算执行
    do {
        // 等待下一次tick到达，比如时针跨度是5秒，但是没有任务，这里需要休息5秒到下一个时针跨度在执行；
        long deadline = this.waitForNextTick();
        if (deadline > 0L) {
            // 获取下一个坐标桶中的位置
            idx = (int)(this.tick & (long)HashedWheelTimer.this.mask);
            // 移除被取消的任务
            this.processCancelledTasks();
            // 获取当前时针下要被执行的任务桶列表
            bucket = HashedWheelTimer.this.wheel[idx];
            // 将新增的客户端列表新传递进来的任务进行编排，这里的编排包括计算下标位置、轮回次数、加入桶列表中等等
            this.transferTimeoutsToBuckets();
            // 执行轮回数为0的任务，并递减每个任务的轮回数
            bucket.expireTimeouts(deadline);
            ++this.tick;
        }
    } while(HashedWheelTimer.WORKER_STATE_UPDATER.get(HashedWheelTimer.this) == 1);

    // 下面就是针对时间轮停止了的情况
    HashedWheelTimer.HashedWheelBucket[] var5 = HashedWheelTimer.this.wheel;
    int var2 = var5.length;
	
    // 将还未执行的任务进行清空
    for(idx = 0; idx < var2; ++idx) {
        bucket = var5[idx];
        bucket.clearTimeouts(this.unprocessedTimeouts);
    }
	
    // 将还没有加入到格子中的待处理定时任务队列中的任务取出，如果是未取消的任务，则加入到未处理任务队列中，以供stop()方法返回
    while(true) {
        HashedWheelTimer.HashedWheelTimeout timeout = (HashedWheelTimer.HashedWheelTimeout)HashedWheelTimer.this.timeouts.poll();
        if (timeout == null) {
            this.processCancelledTasks();
            return;
        }

        if (!timeout.isCancelled()) {
            this.unprocessedTimeouts.add(timeout);
        }
    }
}
```

