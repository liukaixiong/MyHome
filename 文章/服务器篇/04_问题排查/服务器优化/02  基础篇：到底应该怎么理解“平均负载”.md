## uptime

```shell
uptime
02:34:03 up 2 days, 20:14, 1 user, load average: 0.63, 0.83, 0.88
```

- 02:34:03 //当前时间
- up 2 days, 20:14 //系统运行时间
- 1 user //正在登录用户数
- load average: 0.63, 0.83, 0.88 //依次则是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。

### 什么是平均负载?

在一定的单位时间内的可运行状态和不可中断状态下的平均进程数，也就是平均活跃进程数，它和CPU没有直接关系。

- 可运行状态 : 正在使用的CPU和正在等待CPU的进程，也就是我们常用的ps命令看到的，处于R状态的(Running||Runnable)的进程
- 不可中断的状态: 处于内核态关键流程中的进程，并且这些进程是不可中断的，比如我们最常见的等待IO响应的操作。也就是我们在ps命令中看到的D状态(Uninterruptible Sleep 也称为 Disk Sleep)的进程。

> 比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。
>
> 所以，**不可中断状态实际上是系统对进程和硬件设备的一种保护机制。**

平均负载和简单理解为平均活跃进程数。

平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。这个“指数衰减平均”的详细含义你不用计较，这只是系统的一种更快速的计算方式，你把它直接当成活跃进程数的平均值也没问题。既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。比如当平均负载为 2 时，意味着什么呢？

- 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。
- 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。
- 而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。

### 平均负载的合理值

平均负载最理想的情况就是等于CPU的核数。

```shell
# 关于grep和wc的用法请查询它们的手册或者网络搜索
grep 'model name' /proc/cpuinfo | wc -l
```

如果大于CPU的核数，那么表示系统已经过载了。

系统显示的三个指标分别代表1、5、15值该如何分析:

- 如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。
- 但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。
- 反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。

当系统的负载值达到70%的时候，就应该分析排查负载过高的问题了。

因为一旦负载过高会导致进程的响应过慢，进而影响服务的正常功能。



### 平均负载和CPU的使用率

**两者的区别**

平均负载的是指的单位时间内，处于可运行状态和不可中断状态的进程数，所有它不仅包括的正在使用的CPU的活跃进程数，也包括了正在等待CPU和等待IO的进程。

而CPU的使用率，是单位时间内的CPU繁忙的情况，跟平均负载不一定对应。比如：

- CPU密集型。使用大量的CPU繁忙会导致平均负载过高，此时两者是一致的。
- I/O密集型:等待IO也会导致平均负载过高，**但CPU不一定高**;
- 大量等待CPU的进程调度也会导致平均负载升高,此时的CPU的使用率也很高.

### 平均负载的案例

安装压测工具 : stress、sysstat。

#### stress

stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。

而 sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。我们的案例会用到这个包的两个命令 mpstat 和 pidstat。

- mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
- pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。

### 场景一 : CPU密集场景 

```shell
# 使用stress命令使得其中的一个CPU命令达到达到100%
stress --cpu 1 --timeout 600
```

接着在第二个终端查看系统的负载:

```shell
# -d 参数表示高亮显示变化的区域
watch -d uptime
..., load average: 1.00, 0.75, 0.39
```

最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况：

```shell
# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
$ mpstat -P ALL 5
Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)
13:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13:30:11     all   50.05    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95
13:30:11       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13:30:11       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
```

从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。

那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？你可以使用 pidstat 来查询：

```shell
# 间隔5秒后输出一组数据
$ pidstat -u 5 1
13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress
```

### 场景二 : IO密集场景

首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync：

```shell
$ stress -i 1 --timeout 600
```

还是在第二个终端运行 uptime 查看平均负载的变化情况：

```shell
$ watch -d uptime
...,  load average: 1.06, 0.58, 0.37
```

然后，第三个终端运行 mpstat 查看 CPU 使用率的变化情况：

```shell
# 显示所有CPU的指标，并在间隔5秒输出一组数据
$ mpstat -P ALL 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13:41:33     all    0.21    0.00   12.07   32.67    0.00    0.21    0.00    0.00    0.00   54.84
13:41:33       0    0.43    0.00   23.87   67.53    0.00    0.43    0.00    0.00    0.00    7.74
13:41:33       1    0.00    0.00    0.81    0.20    0.00    0.00    0.00    0.00    0.00   98.99
```

从这里可以看到，1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。



那么到底是哪个进程，导致 iowait 这么高呢？我们还是用 pidstat 来查询：

```shell
# 间隔5秒后输出一组数据，-u表示CPU指标
$ pidstat -u 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H
13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H
13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress
13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat
```

### 场景三：大量进程的场景

当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。

比如，我们还是使用 stress，但这次模拟的是 8 个进程：

```shell
$ stress -c 8 --timeout 600
```

由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.97：

```shell
$ uptime
...,  load average: 7.97, 5.93, 3.02
```

接着再运行 pidstat 来看一下进程的情况：

```shell
# 间隔5秒后输出一组数据
$ pidstat -u 5 1
14:23:25      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
14:23:30        0      3190   25.00    0.00    0.00   74.80   25.00     0  stress
14:23:30        0      3191   25.00    0.00    0.00   75.20   25.00     0  stress
14:23:30        0      3192   25.00    0.00    0.00   74.80   25.00     1  stress
14:23:30        0      3193   25.00    0.00    0.00   75.00   25.00     1  stress
14:23:30        0      3194   24.80    0.00    0.00   74.60   24.80     0  stress
14:23:30        0      3195   24.80    0.00    0.00   75.00   24.80     0  stress
14:23:30        0      3196   24.80    0.00    0.00   74.60   24.80     1  stress
14:23:30        0      3197   24.80    0.00    0.00   74.80   24.80     1  stress
14:23:30        0      3200    0.00    0.20    0.00    0.20    0.20     0  pidstat
```

可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。



另外还推荐: htop 、 atop

- htop : 针对CPU和活跃进程的一些监控
- atop: 针对各个层面的监控、磁盘（d）、CPU、网络、活跃进程（p）、用户进程等等