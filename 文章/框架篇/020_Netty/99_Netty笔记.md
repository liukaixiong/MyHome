## Java IO 演进之路

### I/O基础

1. 同步阻塞IO通信模型

   ![1543203436089](D:\github\MyHome\文章\框架篇\020_Netty\assets\1543203436089.png)

   1. 门卫的案例(所有请求交给门卫，由门卫再分发给其他客户。)
      1. 读取数据
      2. 解码
      3. 执行业务操作
      4. 编码
      5. 发送回客户端

   **模型缺点：**
       1）服务端线程个数与客户端并发访问连接数是1：1的关系；
       2）随着客户端并发访问量增大，服务端线程个数线性膨胀，系统性能急剧下降。

2. M:N形式的同步阻塞IO通讯模型[BIO]

   ![1543203419214](D:\github\MyHome\文章\框架篇\020_Netty\assets\1543203419214.png)

   **模型缺点**:

   - BIO的读和写操作都是同步阻塞的，阻塞时间取决于对端IO线程的处理速度和网络IO的传输速度，可靠性差；

   - 当线程池中所有线程都因对端IO线程处理速度慢导致阻塞时，所有后续接入的客户端连接请求都将在任务队列中排队阻塞堆积；
   - 任务队列堆积满后，新的客户端连接请求将被服务端单线程Acceptor阻塞或拒绝，客户端会发生大量连接失败和连接超时。

   **linux的内核模型**

   ![1543203773905](D:\github\MyHome\文章\框架篇\020_Netty\assets\1543203773905.png)

   等待数据准备 -> 等待数据复制  [内核空间 -> 用户空间]

1. 单线程NIO 

![1543212270514](D:\github\MyHome\文章\框架篇\020_Netty\assets\1543212270514.png)

瓶颈会出现在**acceptor**。

acceptor : 接收器

reactor : 事件模型。



**模型优缺点**
    a. 单线程版本Reactor模型优点是不需要做并发控制，代码实现简单清晰；
    b. 缺点是**不能利用多核CPU**，一个线程需要执行处理所有的**accept、read、decode、process、encode、send事件**，如果其中decode、process、encode事件的处理很耗时，则服务端无法及时响应其他客户端的请求事件。

##### 多线程NIO

![1543212591403](D:\github\MyHome\文章\框架篇\020_Netty\assets\1543212591403.png)

可能会遇到的问题:

1. 线程如何分配合理?


**模型缺点：**
    a. 因为Reactor仍是单线程，无法并行响应多个客户端的请求事件（比如同一时刻只能read一个客户端的请求数据）
    

### 同步和异步的差别

同步IO和异步IO区别在于: 数据访问的时候进程是否阻塞!

- 跑到印刷店印书,你没付钱，所以要一直等在这里 - 同步
- 打电话，告诉他需求，然后做自己的事情。 - 异步

阻塞IO和非阻塞IO的区别在于: 应用程序的调用是否立即返回!

- 烧水
  - 阻塞 : 一直盯着开水机，直到开了为止
  - 非阻塞: 水壶开了自己叫，不用人一直等。









### NIO概述

#### 什么是NIO?

同步非阻塞模型



#### 内核空间和用户空间

堆内存/

#### 内核缓冲与进程缓冲



#### 同步与异步



#### 阻塞与非阻塞



























### Linux网络模型





### Java IO演进

### BIO 

#### **ServerSocket**

管道流













## Netty入门

### 什么是Netty ? 

- 异步事件驱动框架，用于快速开发高i性能服务端和客户端
- 封装了JDK底层BIO和NIO模型，提供高度可用的API
- 自带编码解码器解决拆包粘包问题，用户只用关心业务逻辑
- 精心设计的Reactor线程模型支持高并发海量连接
  - 支持高并发非常有效
- 自带协议栈，无需用户关心 
  - 已经实现了大多数协议，用户可以自定义协议

### 第一个Demo



### 核心组件介绍



### Netty VS Nio



## 项目案例

### 手写推送系统

## Netty源码分析



### 线程模型



### IO模型



### Eventloop



### channel

##### 类

1. ServerSocketChannel
2. SocketChannel
3. DatagramChannel
4. FileChannel

##### 方法

1. transferFrom  从哪里读?

读取数据

2. transferTo  读到哪里去

写入数据

### channelhandler



### pipeline



### 内存分配



### ByteBuffer

1. capacity : 容量 ， 规定可读和可写的位置
2. position : 位置
3. limit : 大小
4. mark : 重复读标记

rewind : 重复读方法

flip : 翻转方法，将读的位置设置成开始。



### 编解码



### 性能优化工具



### 设计模式在Netty中的应用



### 单机百万连接调优



### ChannelHandlerContext



### Bootstrap



